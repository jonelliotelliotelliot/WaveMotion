/** * wave-motion.jsx (Refactored for CEP) * * @description The ExtendScript backend for the Wave Motion CEP panel. * Contains all the logic for interacting with After Effects. * * @author jon elliot * @version 1.2 * @date 2025-07-12 */// -----------------------------------------------------------------------------// CONFIGURATION (Copied from original script)// -----------------------------------------------------------------------------var SCRIPT_CONFIG = {    name: "Wave Motion",    version: "1.2",    undo: {        importAction: "Import & Place Comp",        clickAnim: "Apply Click Animation",        backIn: "Apply Back In Ease",        backOut: "Apply Back Out Ease",        backInOut: "Apply Back In/Out Ease",        easePwr1: "Apply Ease Power 1",        easePwr2: "Apply Ease Power 2",        easePwr3: "Apply Ease Power 3",        swatch: "Apply Color Swatch"    },    alert: {        noComp: "Please select or open a composition first.",        noLayer: "Please select at least one layer.",        noKeys: "Please select the appropriate keyframes.",        aepNotFound: "The asset file 'wave-elements.aep' was not found in the script folder.",        compNotFound: "Could not find a comp named “%s” in the imported project."    }};var EASE_CONFIGS = {    backIn:    { offset: 0.5, strength: 0.1, pos: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 60}, {inVal: 90, outVal: 90}], scale: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 60}, {inVal: 90, outVal: 90}] },    backOut:   { offset: 0.5, strength: 0.1, pos: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 20}, {inVal: 75, outVal: 75}], scale: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 20}, {inVal: 75, outVal: 75}] },    backInOut: { offset: 0.3, strength: 0.1, pos: [{inVal: 75, outVal: 75}, {inVal: 35, outVal: 75}, {inVal: 75, outVal: 35}, {inVal: 75, outVal: 75}], scale: [{inVal: 75, outVal: 75}, {inVal: 35, outVal: 75}, {inVal: 75, outVal: 35}, {inVal: 75, outVal: 75}] },    easeInOutPwr1: { pos: [{inVal: 33, outVal: 33}], scale: [{inVal: 33, outVal: 33}] },    easeInOutPwr2: { pos: [{inVal: 66, outVal: 66}], scale: [{inVal: 66, outVal: 66}] },    easeInOutPwr3: { pos: [{inVal: 88, outVal: 88}], scale: [{inVal: 88, outVal: 88}] }};// NOTE: COMP_DEFS and SWATCH_COLORS are now managed in index.html// to make the UI easier to update.// -----------------------------------------------------------------------------// HELPER FUNCTIONS (Internal logic, not called directly from HTML)// -----------------------------------------------------------------------------function findKeyframeSelections(comp, propNames, requiredKeyCount) {    var selections = [];    requiredKeyCount = requiredKeyCount || 0;    var selectedLayers = comp.selectedLayers;    for (var i = 0; i < selectedLayers.length; i++) {        var layer = selectedLayers[i];        var selectedProps = layer.selectedProperties;        for (var j = 0; j < selectedProps.length; j++) {            var prop = selectedProps[j];            var isValidProperty = prop.propertyType === PropertyType.PROPERTY && propNames.indexOf(prop.name) > -1;            if (isValidProperty) {                var selectedKeys = [];                for (var k = 1; k <= prop.numKeys; k++) {                    if (prop.keySelected(k)) selectedKeys.push(k);                }                if (selectedKeys.length > 0 && (requiredKeyCount === 0 || selectedKeys.length === requiredKeyCount)) {                    selections.push({ property: prop, keys: selectedKeys });                }            }        }    }    return selections;}function calculateOvershoot(currentValue, boundaryValue, strength) {    if (Array.isArray(currentValue)) {        return currentValue.map(function(val, i) {            return val + (val - boundaryValue[i]) * strength;        });    }    return currentValue + (currentValue - boundaryValue) * strength;}function applyTemporalEase(prop, times, easeKey) {    var easeConfig = EASE_CONFIGS[easeKey];    var specs = (prop.name === 'Scale') ? easeConfig.scale : easeConfig.pos;    if (specs.length !== times.length) {        var baseSpec = specs[0];        specs = [];        for (var i = 0; i < times.length; i++) specs.push(baseSpec);    }    for (var i = 0; i < times.length; i++) {        var keyIndex = prop.nearestKeyIndex(times[i]);        prop.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);        var spec = specs[i];        var inInfluence = Math.max(spec.inVal, 1);        var outInfluence = Math.max(spec.outVal, 1);        if (prop.name === 'Scale') {            var dimCount = Array.isArray(prop.keyValue(keyIndex)) ? prop.keyValue(keyIndex).length : 1;            var inEaseArray = [], outEaseArray = [];            for (var d = 0; d < dimCount; d++) {                inEaseArray.push(new KeyframeEase(0, inInfluence));                outEaseArray.push(new KeyframeEase(0, outInfluence));            }            prop.setTemporalEaseAtKey(keyIndex, inEaseArray, outEaseArray);        } else {            var easeIn = [new KeyframeEase(0, inInfluence)];            var easeOut = [new KeyframeEase(0, outInfluence)];            prop.setTemporalEaseAtKey(keyIndex, easeIn, easeOut);        }    }}function bakeOvershoot(prop, key1, key2, easeKey) {    var easeConfig = EASE_CONFIGS[easeKey];    var t1 = prop.keyTime(key1), t2 = prop.keyTime(key2);    var v1 = prop.keyValue(key1), v2 = prop.keyValue(key2);    var times = [], values = [];    var offset = easeConfig.offset, strength = easeConfig.strength;    if (easeKey === 'backIn') {        var tOvershoot = t1 + (t2 - t1) * offset;        times = [t1, tOvershoot, t2];        values = [v1, calculateOvershoot(v1, v2, strength), v2];    } else if (easeKey === 'backOut') {        var tOvershoot = t2 - (t2 - t1) * offset;        times = [t1, tOvershoot, t2];        values = [v1, calculateOvershoot(v2, v1, strength), v2];    } else if (easeKey === 'backInOut') {        var tOvershoot1 = t1 + (t2 - t1) * offset;        var tOvershoot2 = t2 - (t2 - t1) * offset;        times = [t1, tOvershoot1, tOvershoot2, t2];        values = [v1, calculateOvershoot(v1, v2, strength), calculateOvershoot(v2, v1, strength), v2];    }    prop.removeKey(key2);    prop.removeKey(key1);    for (var i = 0; i < times.length; i++) {        prop.setValueAtTime(times[i], values[i]);    }    applyTemporalEase(prop, times, easeKey);}function findAndPaintFirstColor(group, color) {    for (var i = 1; i <= group.numProperties; i++) {        var prop = group.property(i);        if (!prop.enabled) continue;        var matchName = prop.matchName;        if (matchName === "ADBE Vector Graphic - Fill" || matchName === "ADBE Vector Graphic - Stroke") {            try {                prop.property("Color").setValue(color);                return true;            } catch (e) {}        } else if (matchName === "ADBE Vector Group") {            if (findAndPaintFirstColor(prop.property("Contents"), color)) {                return true;            }        }    }    return false;}/** * Forces the After Effects undo stack to clean itself up to work around an engine-level bug. * It performs a harmless, undoable action and then immediately triggers the Undo command. */function forceUndoStackCleanup() {    try {        var comp = app.project.activeItem;        if (comp && comp instanceof CompItem) {            app.beginUndoGroup("Undo Stack Cleanup");            var tempLayer = comp.layers.addNull(0.1);            tempLayer.remove();            app.endUndoGroup();            app.executeCommand(app.findMenuCommandId("Undo"));        }    } catch (e) {        // Fail silently. This is a cleanup utility, not a core function.    }}// -----------------------------------------------------------------------------// MAIN FUNCTIONS (Called from index.html via evalScript)// -----------------------------------------------------------------------------/** * Imports a specific composition and its dependencies from a project file, * then adds it to the active comp. It cleans up by moving needed items * to a new folder and deleting the rest. *//** * Imports a specific composition and its dependencies from a project file, * then adds it to the active comp. It cleans up by moving needed items * to a new folder and deleting the rest. */function importAndPlaceComp(defAsJSON, extensionPath) {    var activeComp = app.project.activeItem;    if (!(activeComp instanceof CompItem)) {        return JSON.stringify({            success: false,            message: "No active composition. Please open or select a composition in the timeline before importing."        });    }    var result = { success: true, message: "" };    var def = JSON.parse(defAsJSON);    var compName = def.name;    app.beginUndoGroup(SCRIPT_CONFIG.undo.importAction + " “" + compName + "”");    try {        var targetComp = null;        // Step 1: Find if the comp already exists in the project        for (var i = 1; i <= app.project.numItems; i++) {            var item = app.project.item(i);            if (item instanceof CompItem && item.name === compName) {                targetComp = item;                break;            }        }        // Step 2: If it doesn't exist, import and prune        if (!targetComp) {            var aepFile = new File(extensionPath + "/elements/wave-elements.aep");            if (!aepFile.exists) {                throw new Error("The asset file 'wave-elements.aep' was not found at: " + aepFile.fsName);            }            var importOptions = new ImportOptions(aepFile);            var importedFolder = app.project.importFile(importOptions);            function findCompInFolder(folder, name) {                for (var i = 1; i <= folder.numItems; i++) {                    var item = folder.item(i);                    if (item instanceof CompItem && item.name === name) {                        return item;                    } else if (item instanceof FolderItem) {                        var found = findCompInFolder(item, name);                        if (found) return found;                    }                }                return null;            }            targetComp = findCompInFolder(importedFolder, compName);            if (!targetComp) {                throw new Error("Could not find comp “" + compName + "” in the project after attempting to import it.");            }            var itemsToKeep = [targetComp];            getAllDependencies(targetComp, itemsToKeep);            var folderName = "Wave Motion Assets";            var assetsFolder = null;            for (var f = 1; f <= app.project.numItems; f++) {                var projItem = app.project.item(f);                if (projItem instanceof FolderItem && projItem.name === folderName && projItem.parentFolder === app.project.rootFolder) {                    assetsFolder = projItem;                    break;                }            }            if (assetsFolder === null) {                assetsFolder = app.project.items.addFolder(folderName);            }            for (var m = 0; m < itemsToKeep.length; m++) {                var itemToMove = itemsToKeep[m];                if (itemToMove.parentFolder !== assetsFolder) {                    itemToMove.parentFolder = assetsFolder;                }            }                        importedFolder.remove();        }        // Step 3: Add the comp to the timeline        var currentTime = activeComp.time;        var newLayer = activeComp.layers.add(targetComp);        newLayer.startTime = currentTime;        newLayer.anchorPoint.setValue(def.anchor);                if (def.collapse !== undefined) {             newLayer.collapseTransformation = def.collapse;        }        result.message = "Added '" + compName + "' to the composition.";    } catch (e) {        result.success = false;        result.message = e.toString();    } finally {        // This block is guaranteed to run, ensuring the undo group is always closed.        app.endUndoGroup();    }    return JSON.stringify(result);}/** * Recursively finds all items used by a source composition by manually * checking the source of each layer. This is more reliable than using .usedItems. * @param {CompItem} sourceComp The composition to scan for dependencies. * @param {Array} collectedArray The array to store the collected dependencies. */function getAllDependencies(sourceComp, collectedArray) {    if (!sourceComp || !(sourceComp instanceof CompItem)) {        return;    }    // Loop through all layers in this composition    for (var i = 1; i <= sourceComp.numLayers; i++) {        var layer = sourceComp.layer(i);        var source = layer.source; // Get the source item from the Project panel        // Check if the layer has a valid source (e.g., not a Text layer or Shape layer without a source)        if (source && source.id) {            var isAlreadyCollected = false;            for (var j = 0; j < collectedArray.length; j++) {                if (source.id === collectedArray[j].id) {                    isAlreadyCollected = true;                    break;                }            }            if (!isAlreadyCollected) {                collectedArray.push(source);                // If the source is another comp, we need to find ITS dependencies too.                if (source instanceof CompItem) {                    getAllDependencies(source, collectedArray);                }            }        }    }}function applyClickAnimation() {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    if (comp.selectedLayers.length === 0) {        alert(SCRIPT_CONFIG.alert.noLayer);        return;    }    app.beginUndoGroup(SCRIPT_CONFIG.undo.clickAnim);    try {        var layer = comp.selectedLayers[0];        var scaleProp = layer.property("Scale");        var originalScale = scaleProp.value;        var clickedScale = [originalScale[0] * 0.9, originalScale[1] * 0.9];        var t0 = comp.time;        var frameDuration = comp.frameDuration;        var times = [t0, t0 + frameDuration * 4, t0 + frameDuration * 8];        var values = [originalScale, clickedScale, originalScale];        scaleProp.setValuesAtTimes(times, values);        var inInfluence = 66, outInfluence = 66;        for (var i = 0; i < times.length; i++) {            var keyIndex = scaleProp.nearestKeyIndex(times[i]);            scaleProp.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);            var dimCount = Array.isArray(scaleProp.keyValue(keyIndex)) ? scaleProp.keyValue(keyIndex).length : 1;            var inEaseArray = [], outEaseArray = [];            for (var d = 0; d < dimCount; d++) {                inEaseArray.push(new KeyframeEase(0, inInfluence));                outEaseArray.push(new KeyframeEase(0, outInfluence));            }            scaleProp.setTemporalEaseAtKey(keyIndex, inEaseArray, outEaseArray);        }    } catch (e) {        alert("Could not apply click animation: " + e.toString());    } finally {        app.endUndoGroup();    }}/** * Generic handler for all easing types. * @param {string} easeKey The key corresponding to EASE_CONFIGS (e.g., "backIn"). */function applyEase(easeKey) {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }        var undoName = SCRIPT_CONFIG.undo[easeKey] || "Apply Ease";    var isBackEase = easeKey.indexOf('back') === 0;    var requiredKeys = isBackEase ? 2 : 0;    var propNames = ["Position", "Scale", "Rotation"];    var selections = findKeyframeSelections(comp, propNames, requiredKeys);        if (selections.length === 0) {        alert(SCRIPT_CONFIG.alert.noKeys);        return;    }    app.beginUndoGroup(undoName);    try {        for (var i = 0; i < selections.length; i++) {            var item = selections[i];            if (isBackEase) {                bakeOvershoot(item.property, item.keys[0], item.keys[1], easeKey);            } else {                var times = item.keys.map(function(keyIndex) {                    return item.property.keyTime(keyIndex);                });                applyTemporalEase(item.property, times, easeKey);            }        }    } catch (e) {        alert("Could not apply ease: " + e.toString());    } finally {        app.endUndoGroup();    }}//https://ae-scripting.docsforadobe.dev/matchnames/layer/textlayer/#animators//// 1) A single “worker” function that takes the only thing that changes:function applyTextAnimation(rangeType, animatorName) {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert("Please select a composition.");        return;    }    var layers = comp.selectedLayers;    if (layers.length !== 1 || !(layers[0] instanceof TextLayer)) {        alert("Please select exactly one text layer.");        return;    }    app.beginUndoGroup("Apply Text Animation");    try {        var textLayer = layers[0];        var animator = textLayer            .property("ADBE Text Properties")            .property("ADBE Text Animators")            .addProperty("ADBE Text Animator");        animator.name = animatorName;        var props = animator.property("ADBE Text Animator Properties");        props.addProperty("ADBE Text Position 3D").setValue([0, 15, 0]);        props.addProperty("ADBE Text Opacity").setValue(0);        var selector = animator            .property("ADBE Text Selectors")            .addProperty("ADBE Text Selector");        var adv = selector.property("ADBE Text Range Advanced");        adv.property("ADBE Text Range Type2").setValue(rangeType);        adv.property("ADBE Text Range Shape").setValue(3);        adv.property("ADBE Text Levels Max Ease").setValue(78);        adv.property("ADBE Text Levels Min Ease").setValue(0);        adv.property("ADBE Text Selector Mode").setValue(2);        var offset = selector.property("ADBE Text Percent Offset");        if (!offset) {            throw new Error("Couldn't find Offset property!");        }        var t0 = comp.time;        var secPerFrame = 1 / comp.frameRate;        var rampFrames = 25;        var gapFrames = 75;        var ramp = rampFrames * secPerFrame;        var gap = gapFrames * secPerFrame;        var endTime = t0 + ramp + gap + ramp;        offset.setValueAtTime(t0, -100);        offset.setValueAtTime(t0 + ramp, 100);        offset.setValueAtTime(t0 + ramp + gap, 100);        offset.setValueAtTime(endTime, -100);    } catch(e) {        alert("Could not apply text animation: " + e.toString());    } finally {        app.endUndoGroup();    }}/** * Copies the temporal ease objects from all selected keyframes. * @returns {string} A JSON string representing an array of ease objects, or an empty array string. */function copySelectedEases() {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) { return "[]"; }     var copiedEases = [];    var selectedLayers = comp.selectedLayers;    for (var i = 0; i < selectedLayers.length; i++) {        var layer = selectedLayers[i];        var selectedProps = layer.selectedProperties;        for (var j = 0; j < selectedProps.length; j++) {            var prop = selectedProps[j];            if (prop.propertyType === PropertyType.PROPERTY && prop.numKeys > 0) {                for (var k = 1; k <= prop.numKeys; k++) {                    if (prop.keySelected(k)) {                        var inEase  = prop.keyInTemporalEase(k);                        var outEase = prop.keyOutTemporalEase(k);                        var easeObj = { inEase: [], outEase: [] };                        for (var e = 0; e < inEase.length; e++) {                            easeObj.inEase.push({ speed: inEase[e].speed, influence: inEase[e].influence });                        }                        for (var e = 0; e < outEase.length; e++) {                            easeObj.outEase.push({ speed: outEase[e].speed, influence: outEase[e].influence });                        }                        copiedEases.push(easeObj);                    }                }            }        }    }     if (copiedEases.length === 0) {        alert("Please select one or more keyframes to copy their easing.");        return "[]";    }    // SUCCESS ALERT for COPY    alert("Copied easing from " + copiedEases.length + " keyframe(s).");    return JSON.stringify(copiedEases);}/** * Pastes copied easing data onto the currently selected keyframes. * @param {string} easesAsJSON The JSON string of ease data, or null. *//** * Pastes copied easing data onto the currently selected keyframes. * This version adapts the copied ease to match the dimensions of the target property. * @param {string} easesAsJSON The JSON string of ease data, or null. *//** * Pastes copied easing data onto the currently selected keyframes. * This definitive version creates a "best-fit" by adapting the copied ease * to the target property's specific easing structure (spatial or dimensional). * @param {string} easesAsJSON The JSON string of ease data, or null. */function pasteSelectedEases(easesAsJSON) {    if (!easesAsJSON || easesAsJSON === "null") {        alert('No easing data has been copied yet. Please use "Copy Easing" first.');        return;    }    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    var easesToApply;    try {        easesToApply = JSON.parse(easesAsJSON);    } catch (e) {        alert("Pasting failed: The copied ease data appears to be corrupt.");        return;    }    var targetKeyframes = [];    var selectedLayers = comp.selectedLayers;    for (var i = 0; i < selectedLayers.length; i++) {        var layer = selectedLayers[i];        var selectedProps = layer.selectedProperties;        for (var j = 0; j < selectedProps.length; j++) {            var prop = selectedProps[j];            if (prop.propertyType === PropertyType.PROPERTY && prop.numKeys > 0) {                for (var k = 1; k <= prop.numKeys; k++) {                    if (prop.keySelected(k)) {                        targetKeyframes.push({ property: prop, keyIndex: k });                    }                }            }        }    }    if (targetKeyframes.length === 0) {        alert("Please select the keyframe(s) you want to paste the easing onto.");        return;    }    if (targetKeyframes.length !== easesToApply.length) {        alert("The number of copied keyframes (" + easesToApply.length + ") does not match the number of selected keyframes for pasting (" + targetKeyframes.length + ").");        return;    }    app.beginUndoGroup("Paste Keyframe Easing");    var pasteSuccess = false;    try {        for (var i = 0; i < targetKeyframes.length; i++) {            var target = targetKeyframes[i];            var sourceEase = easesToApply[i];            if (!sourceEase || !sourceEase.inEase || sourceEase.inEase.length === 0) continue;            // --- NEW: UNIVERSAL EASE TRANSLATION LOGIC ---            // 1. Get the master ease from the first dimension of the copied source.            //    This works whether the source is 1D, dimensional, or spatial.            var masterInEase = sourceEase.inEase[0];            var masterOutEase = sourceEase.outEase[0];            // 2. Determine the required structure for the TARGET property's ease array.            var requiredEaseDimensions;            var propValType = target.property.propertyValueType;            if (propValType === PropertyValueType.TwoD_SPATIAL || propValType === PropertyValueType.ThreeD_SPATIAL) {                // Spatial properties (like Position) ALWAYS expect a single ease object.                requiredEaseDimensions = 1;            } else {                // Dimensional properties (Scale, Anchor Point) and 1D properties (Rotation)                // expect an ease object for each dimension in their value.                var targetValue = target.property.keyValue(target.keyIndex);                requiredEaseDimensions = (targetValue instanceof Array) ? targetValue.length : 1;            }            // 3. Build the new ease arrays with the perfect size for the target.            var newInEase = [];            var newOutEase = [];            for (var d = 0; d < requiredEaseDimensions; d++) {                // Apply the master ease to every required dimension.                newInEase.push(new KeyframeEase(masterInEase.speed, masterInEase.influence));                newOutEase.push(new KeyframeEase(masterOutEase.speed, masterOutEase.influence));            }            // 4. Apply the perfectly formatted ease data.            target.property.setTemporalEaseAtKey(target.keyIndex, newInEase, newOutEase);            target.property.setInterpolationTypeAtKey(target.keyIndex, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);        }        pasteSuccess = true;    } catch (e) {        alert("An error occurred while pasting the ease: " + e.toString());        pasteSuccess = false;    } finally {        app.endUndoGroup();    }    if (pasteSuccess) {        alert("Pasted easing onto " + targetKeyframes.length + " keyframe(s).");    }}// 2) Two tiny wrappers that just pass the right arguments:function applyCharAnimation() {  // ADBE Text Range Type2 → 2 for “characters”  applyTextAnimation(2, "Wavemotion-Char-Animator");}function applyWordAnimation() {  // ADBE Text Range Type2 → 1 for “words”  applyTextAnimation(3, "Wavemotion-Word-Animator");}/** * Deconstructs a selected pre-comp layer, replacing it with its contents. * The contents are parented to a new Null Object that inherits the * transformations of the original pre-comp layer. */function deconstructPrecomp() {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert("Please select a composition first.");        return;    }    var selectedLayers = comp.selectedLayers;    if (selectedLayers.length !== 1) {        alert("Please select exactly one pre-comp layer to deconstruct.");        return;    }    var precompLayer = selectedLayers[0];    if (!(precompLayer.source instanceof CompItem)) {        alert("The selected layer is not a pre-comp.");        return;    }    app.beginUndoGroup("Deconstruct Pre-comp");    try {        var sourceComp = precompLayer.source;        var precompTransform = precompLayer.property("Transform");        // 1. Create a Null to act as the new parent        var nullLayer = comp.layers.addNull(comp.duration);        nullLayer.name = precompLayer.name + " Controller";                if (precompLayer.threeDLayer) {            nullLayer.threeDLayer = true;        }        nullLayer.moveBefore(precompLayer);        nullLayer.startTime = precompLayer.startTime;        var nullTransform = nullLayer.property("Transform");        // 2. Copy the transform properties from the pre-comp to the Null        var propsToCopy = ["Anchor Point", "Position", "Scale", "Rotation", "Opacity"];        for (var i = 0; i < propsToCopy.length; i++) {            var propName = propsToCopy[i];            var sourceProp = precompTransform.property(propName);            var targetProp = nullTransform.property(propName);                        if (sourceProp.numKeys > 0) {                for (var k = 1; k <= sourceProp.numKeys; k++) {                    targetProp.setValueAtTime(sourceProp.keyTime(k), sourceProp.keyValue(k));                }            } else {                targetProp.setValue(sourceProp.value);            }        }        // 3. Copy layers from the source comp into the main comp        var lastPastedLayer = nullLayer;        for (var j = 1; j <= sourceComp.numLayers; j++) {            var layerToCopy = sourceComp.layer(j);                        // --- NEW: Bulletproof method to find the new layer ---            // A. Get a list of all layer IDs BEFORE we copy.            var existingLayerIDs = {};            for (var k = 1; k <= comp.numLayers; k++) {                existingLayerIDs[comp.layer(k).id] = true;            }            // B. Copy the layer.            layerToCopy.copyToComp(comp);            // C. Find the one layer whose ID is not in our original list.            var newLayer = null;            for (var k = 1; k <= comp.numLayers; k++) {                var currentLayer = comp.layer(k);                if (!existingLayerIDs[currentLayer.id]) {                    newLayer = currentLayer;                    break;                 }            }            if (newLayer === null) {                throw new Error("Failed to get a reference to the newly created layer.");            }            // --- End of new method ---                        newLayer.moveAfter(lastPastedLayer);            newLayer.parent = nullLayer;            newLayer.startTime = layerToCopy.startTime + precompLayer.startTime;                        var newLayerTransform = newLayer.property("Transform");            var oldLayerTransform = layerToCopy.property("Transform");                        for (var p = 0; p < propsToCopy.length; p++) {                var propNameToSet = propsToCopy[p];                var propToSet = newLayerTransform.property(propNameToSet);                                if (propToSet.numKeys === 0) {                    propToSet.setValue(oldLayerTransform.property(propNameToSet).value);                }            }            lastPastedLayer = newLayer;        }        // 4. Remove the original pre-comp layer        precompLayer.remove();    } catch (e) {        alert("An error occurred during de-comp: " + e.toString());    } finally {        app.endUndoGroup();    }}/** * Applies a color from a swatch to selected layers or properties. * @param {string} colorAsJSON A JSON string of the RGB color array (e.g., "[0.5, 0.5, 0.5]"). */function applySwatchColor(colorAsJSON) {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    app.beginUndoGroup(SCRIPT_CONFIG.undo.swatch);    try {        var rgbColor = JSON.parse(colorAsJSON);        var painted = 0;        // 1) First, handle any directly-selected fill/stroke props        var selectedProps = comp.selectedProperties;        if (selectedProps && selectedProps.length) {            var targetMatchNames = [                "ADBE Vector Fill Color",                "ADBE Vector Stroke Color",                "ADBE Text Fill Color",                "ADBE Text Stroke Color"            ];            for (var i = 0; i < selectedProps.length; i++) {                var prop = selectedProps[i];                if (targetMatchNames.indexOf(prop.matchName) > -1) {                    prop.setValue(rgbColor);                    painted++;                }            }        }        // 2) If none of the above fired, fall back to whole-layer coloring        if (painted === 0) {            var selectedLayers = comp.selectedLayers;            for (var i = 0; i < selectedLayers.length; i++) {                var layer = selectedLayers[i];                if (layer instanceof TextLayer) {                    var textProp = layer.property("Source Text");                    var textDoc = textProp.value;                    textDoc.fillColor = rgbColor;                    textDoc.applyStroke = false;                    textDoc.strokeColor = rgbColor;                    textProp.setValue(textDoc);                    painted++;                } else if (layer.matchName === "ADBE Vector Layer") {                    if (findAndPaintFirstColor(layer.property("Contents"), rgbColor)) {                        painted++;                    }                }            }        }    } catch (e) {        // Silently fail is okay for this function, but we must catch errors        // to ensure the 'finally' block runs.    } finally {        // This guarantees the undo group is always closed.        app.endUndoGroup();    }}