/** * wave-motion.jsx (Refactored for CEP) * * @description The ExtendScript backend for the Wave Motion CEP panel. * Contains all the logic for interacting with After Effects. * * @author jon elliot * @version 1.1 * @date 2025-07-06 */// -----------------------------------------------------------------------------// CONFIGURATION (Copied from original script)// -----------------------------------------------------------------------------var SCRIPT_CONFIG = {    name: "Wave Motion",    version: "1.0",    undo: {        importAction: "Import & Place Comp",        clickAnim: "Apply Click Animation",        backIn: "Apply Back In Ease",        backOut: "Apply Back Out Ease",        backInOut: "Apply Back In/Out Ease",        easePwr1: "Apply Ease Power 1",        easePwr2: "Apply Ease Power 2",        easePwr3: "Apply Ease Power 3",        swatch: "Apply Color Swatch"    },    alert: {        noComp: "Please select or open a composition first.",        noLayer: "Please select at least one layer.",        noKeys: "Please select the appropriate keyframes.",        aepNotFound: "The asset file 'wave-elements.aep' was not found in the script folder.",        compNotFound: "Could not find a comp named “%s” in the imported project."    }};var EASE_CONFIGS = {    backIn:    { offset: 0.5, strength: 0.1, pos: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 60}, {inVal: 90, outVal: 90}], scale: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 60}, {inVal: 90, outVal: 90}] },    backOut:   { offset: 0.5, strength: 0.1, pos: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 20}, {inVal: 75, outVal: 75}], scale: [{inVal: 88, outVal: 88}, {inVal: 35, outVal: 20}, {inVal: 75, outVal: 75}] },    backInOut: { offset: 0.3, strength: 0.1, pos: [{inVal: 75, outVal: 75}, {inVal: 35, outVal: 75}, {inVal: 75, outVal: 35}, {inVal: 75, outVal: 75}], scale: [{inVal: 75, outVal: 75}, {inVal: 35, outVal: 75}, {inVal: 75, outVal: 35}, {inVal: 75, outVal: 75}] },    easeInOutPwr1: { pos: [{inVal: 33, outVal: 33}], scale: [{inVal: 33, outVal: 33}] },    easeInOutPwr2: { pos: [{inVal: 66, outVal: 66}], scale: [{inVal: 66, outVal: 66}] },    easeInOutPwr3: { pos: [{inVal: 88, outVal: 88}], scale: [{inVal: 88, outVal: 88}] }};// NOTE: COMP_DEFS and SWATCH_COLORS are now managed in index.html// to make the UI easier to update.// -----------------------------------------------------------------------------// HELPER FUNCTIONS (Internal logic, not called directly from HTML)// -----------------------------------------------------------------------------function findKeyframeSelections(comp, propNames, requiredKeyCount) {    var selections = [];    requiredKeyCount = requiredKeyCount || 0;    var selectedLayers = comp.selectedLayers;    for (var i = 0; i < selectedLayers.length; i++) {        var layer = selectedLayers[i];        var selectedProps = layer.selectedProperties;        for (var j = 0; j < selectedProps.length; j++) {            var prop = selectedProps[j];            var isValidProperty = prop.propertyType === PropertyType.PROPERTY && propNames.indexOf(prop.name) > -1;            if (isValidProperty) {                var selectedKeys = [];                for (var k = 1; k <= prop.numKeys; k++) {                    if (prop.keySelected(k)) selectedKeys.push(k);                }                if (selectedKeys.length > 0 && (requiredKeyCount === 0 || selectedKeys.length === requiredKeyCount)) {                    selections.push({ property: prop, keys: selectedKeys });                }            }        }    }    return selections;}function calculateOvershoot(currentValue, boundaryValue, strength) {    if (Array.isArray(currentValue)) {        return currentValue.map(function(val, i) {            return val + (val - boundaryValue[i]) * strength;        });    }    return currentValue + (currentValue - boundaryValue) * strength;}function applyTemporalEase(prop, times, easeKey) {    var easeConfig = EASE_CONFIGS[easeKey];    var specs = (prop.name === 'Scale') ? easeConfig.scale : easeConfig.pos;    if (specs.length !== times.length) {        var baseSpec = specs[0];        specs = [];        for (var i = 0; i < times.length; i++) specs.push(baseSpec);    }    for (var i = 0; i < times.length; i++) {        var keyIndex = prop.nearestKeyIndex(times[i]);        prop.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);        var spec = specs[i];        var inInfluence = Math.max(spec.inVal, 1);        var outInfluence = Math.max(spec.outVal, 1);        if (prop.name === 'Scale') {            var dimCount = Array.isArray(prop.keyValue(keyIndex)) ? prop.keyValue(keyIndex).length : 1;            var inEaseArray = [], outEaseArray = [];            for (var d = 0; d < dimCount; d++) {                inEaseArray.push(new KeyframeEase(0, inInfluence));                outEaseArray.push(new KeyframeEase(0, outInfluence));            }            prop.setTemporalEaseAtKey(keyIndex, inEaseArray, outEaseArray);        } else {            var easeIn = [new KeyframeEase(0, inInfluence)];            var easeOut = [new KeyframeEase(0, outInfluence)];            prop.setTemporalEaseAtKey(keyIndex, easeIn, easeOut);        }    }}function bakeOvershoot(prop, key1, key2, easeKey) {    var easeConfig = EASE_CONFIGS[easeKey];    var t1 = prop.keyTime(key1), t2 = prop.keyTime(key2);    var v1 = prop.keyValue(key1), v2 = prop.keyValue(key2);    var times = [], values = [];    var offset = easeConfig.offset, strength = easeConfig.strength;    if (easeKey === 'backIn') {        var tOvershoot = t1 + (t2 - t1) * offset;        times = [t1, tOvershoot, t2];        values = [v1, calculateOvershoot(v1, v2, strength), v2];    } else if (easeKey === 'backOut') {        var tOvershoot = t2 - (t2 - t1) * offset;        times = [t1, tOvershoot, t2];        values = [v1, calculateOvershoot(v2, v1, strength), v2];    } else if (easeKey === 'backInOut') {        var tOvershoot1 = t1 + (t2 - t1) * offset;        var tOvershoot2 = t2 - (t2 - t1) * offset;        times = [t1, tOvershoot1, tOvershoot2, t2];        values = [v1, calculateOvershoot(v1, v2, strength), calculateOvershoot(v2, v1, strength), v2];    }    prop.removeKey(key2);    prop.removeKey(key1);    for (var i = 0; i < times.length; i++) {        prop.setValueAtTime(times[i], values[i]);    }    applyTemporalEase(prop, times, easeKey);}function findAndPaintFirstColor(group, color) {    for (var i = 1; i <= group.numProperties; i++) {        var prop = group.property(i);        if (!prop.enabled) continue;        var matchName = prop.matchName;        if (matchName === "ADBE Vector Graphic - Fill" || matchName === "ADBE Vector Graphic - Stroke") {            try {                prop.property("Color").setValue(color);                return true;            } catch (e) {}        } else if (matchName === "ADBE Vector Group") {            if (findAndPaintFirstColor(prop.property("Contents"), color)) {                return true;            }        }    }    return false;}// -----------------------------------------------------------------------------// MAIN FUNCTIONS (Called from index.html via evalScript)// -----------------------------------------------------------------------------/** * Imports a composition from a project file and adds it to the active comp. * @param {string} defAsJSON A JSON string of the comp definition object {name, anchor, collapse}. */// In jsx/wave-motion.jsxfunction importAndPlaceComp(defAsJSON, extensionPath) {    var activeComp = app.project.activeItem;    if (!activeComp || !(activeComp instanceof CompItem)) {        return JSON.stringify({            success: false,            message: "No active composition. Please open or select a composition in the timeline before importing."        });    }    try {        var def = JSON.parse(defAsJSON);        var compName = def.name;        // --- Step 1: Find if the comp already exists in the project ---        var targetComp = null;        for (var i = 1; i <= app.project.numItems; i++) {            var item = app.project.item(i);            if (item instanceof CompItem && item.name === compName) {                targetComp = item;                break;            }        }        // --- Step 2: If it doesn't exist, import it ---        if (!targetComp) {            var aepFile = new File(extensionPath + "/elements/wave-elements.aep");            if (!aepFile.exists) {                return JSON.stringify({                    success: false,                    message: "The asset file 'wave-elements.aep' was not found at: " + aepFile.fsName                });            }            // Import the entire .aep file. AE handles this as a single undoable action.            app.project.importFile(new ImportOptions(aepFile));            // Now, find the comp again after the import            for (var i = 1; i <= app.project.numItems; i++) {                var item = app.project.item(i);                if (item instanceof CompItem && item.name === compName) {                    targetComp = item;                    break;                }            }        }        if (!targetComp) {            return JSON.stringify({                success: false,                message: "Could not find comp “" + compName + "” in the project after attempting to import it."            });        }        // --- Step 3: Add the comp to the timeline (this is the part we wrap in an undo group) ---        app.beginUndoGroup(SCRIPT_CONFIG.undo.importAction + " “" + compName + "”");        var currentTime = activeComp.time;        var newLayer = activeComp.layers.add(targetComp);        newLayer.startTime = currentTime;        newLayer.anchorPoint.setValue(def.anchor);                if (def.collapse !== undefined) {             newLayer.collapseTransformation = def.collapse;        }        app.endUndoGroup();        return JSON.stringify({            success: true,            message: "Added '" + compName + "' to the composition."        });    } catch (e) {        // Just in case an error happened inside the undo group, we should try to close it.        app.endUndoGroup();        return JSON.stringify({            success: false,            message: "An unexpected error occurred: " + e.toString()        });    }}/** * Applies a pre-defined click animation to the selected layer's scale. */function applyClickAnimation() {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    if (comp.selectedLayers.length === 0) {        alert(SCRIPT_CONFIG.alert.noLayer);        return;    }    app.beginUndoGroup(SCRIPT_CONFIG.undo.clickAnim);    var layer = comp.selectedLayers[0];    var scaleProp = layer.property("Scale");    var originalScale = scaleProp.value;    var clickedScale = [originalScale[0] * 0.9, originalScale[1] * 0.9];    var t0 = comp.time;    var frameDuration = comp.frameDuration;    var times = [t0, t0 + frameDuration * 4, t0 + frameDuration * 8];    var values = [originalScale, clickedScale, originalScale];    scaleProp.setValuesAtTimes(times, values);    var inInfluence = 66, outInfluence = 66;    for (var i = 0; i < times.length; i++) {        var keyIndex = scaleProp.nearestKeyIndex(times[i]);        scaleProp.setInterpolationTypeAtKey(keyIndex, KeyframeInterpolationType.BEZIER, KeyframeInterpolationType.BEZIER);        var dimCount = Array.isArray(scaleProp.keyValue(keyIndex)) ? scaleProp.keyValue(keyIndex).length : 1;        var inEaseArray = [], outEaseArray = [];        for (var d = 0; d < dimCount; d++) {            inEaseArray.push(new KeyframeEase(0, inInfluence));            outEaseArray.push(new KeyframeEase(0, outInfluence));        }        scaleProp.setTemporalEaseAtKey(keyIndex, inEaseArray, outEaseArray);    }    app.endUndoGroup();}/** * Generic handler for all easing types. * @param {string} easeKey The key corresponding to EASE_CONFIGS (e.g., "backIn"). */function applyEase(easeKey) {    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    var undoName = SCRIPT_CONFIG.undo[easeKey] || "Apply Ease";    var isBackEase = easeKey.indexOf('back') === 0;    var requiredKeys = isBackEase ? 2 : 0;    var propNames = ["Position", "Scale", "Rotation"];    var selections = findKeyframeSelections(comp, propNames, requiredKeys);    if (selections.length === 0) {        alert(SCRIPT_CONFIG.alert.noKeys);        return;    }    app.beginUndoGroup(undoName);    for (var i = 0; i < selections.length; i++) {        var item = selections[i];        if (isBackEase) {            bakeOvershoot(item.property, item.keys[0], item.keys[1], easeKey);        } else {            var times = item.keys.map(function(keyIndex) {                return item.property.keyTime(keyIndex);            });            applyTemporalEase(item.property, times, easeKey);        }    }    app.endUndoGroup();}//https://ae-scripting.docsforadobe.dev/matchnames/layer/textlayer/#animators//// 1) A single “worker” function that takes the only thing that changes:function applyTextAnimation(rangeType, animatorName) {  app.beginUndoGroup("Apply Text Animation");  var comp = app.project.activeItem;  if (!(comp instanceof CompItem)) {    alert("Please select a composition.");    return;  }  var layers = comp.selectedLayers;  if (layers.length !== 1 || !(layers[0] instanceof TextLayer)) {    alert("Please select exactly one text layer.");    return;  }  var textLayer = layers[0];  // — Text Animator & Properties —  var animator = textLayer    .property("ADBE Text Properties")    .property("ADBE Text Animators")    .addProperty("ADBE Text Animator");  animator.name = animatorName;  var props = animator.property("ADBE Text Animator Properties");  props.addProperty("ADBE Text Position 3D").setValue([0,15,0]);  props.addProperty("ADBE Text Opacity").     setValue(0);  // — Range Selector —  var selector = animator    .property("ADBE Text Selectors")    .addProperty("ADBE Text Selector");  var adv = selector.property("ADBE Text Range Advanced");  // here’s the only line that’s different between “char” and “word” modes:  adv.property("ADBE Text Range Type2").setValue(rangeType);  adv.property("ADBE Text Range Shape").        setValue(3);  adv.property("ADBE Text Levels Max Ease").    setValue(78);  adv.property("ADBE Text Levels Min Ease").    setValue( 0);  adv.property("ADBE Text Selector Mode").      setValue(2);  // — Offset Keyframes off the PLAYHEAD —    var offset = selector.property("ADBE Text Percent Offset");  if (!offset) {    alert("Couldn't find Offset!");    app.endUndoGroup();    return;  }  var t0           = comp.time;  var secPerFrame  = 1 / comp.frameRate;  var rampFrames   = 25;  var gapFrames    = 75;  var ramp         = rampFrames * secPerFrame;  var gap          = gapFrames  * secPerFrame;  var endTime      = t0 + ramp + gap + ramp;  offset.setValueAtTime(t0,               -100);  offset.setValueAtTime(t0 + ramp,         100);  offset.setValueAtTime(t0 + ramp + gap,   100);  offset.setValueAtTime(endTime,           -100);  app.endUndoGroup();}// 2) Two tiny wrappers that just pass the right arguments:function applyCharAnimation() {  // ADBE Text Range Type2 → 2 for “characters”  applyTextAnimation(2, "Wavemotion-Char-Animator");}function applyWordAnimation() {  // ADBE Text Range Type2 → 1 for “words”  applyTextAnimation(3, "Wavemotion-Word-Animator");}/** * Applies a color from a swatch to selected layers or properties. * @param {string} colorAsJSON A JSON string of the RGB color array (e.g., "[0.5, 0.5, 0.5]"). */function applySwatchColor(colorAsJSON) {    var rgbColor = JSON.parse(colorAsJSON);    var comp = app.project.activeItem;    if (!(comp instanceof CompItem)) {        alert(SCRIPT_CONFIG.alert.noComp);        return;    }    app.beginUndoGroup(SCRIPT_CONFIG.undo.swatch);    var painted = 0;    // 1) First, handle any directly-selected fill/stroke props (vector shapes or animators)    var selectedProps = comp.selectedProperties;    if (selectedProps && selectedProps.length) {        var targetMatchNames = [            "ADBE Vector Fill Color",            "ADBE Vector Stroke Color",            "ADBE Text Fill Color",            "ADBE Text Stroke Color"        ];        for (var i = 0; i < selectedProps.length; i++) {            var prop = selectedProps[i];            if (targetMatchNames.indexOf(prop.matchName) > -1) {                prop.setValue(rgbColor);                painted++;            }        }    }    // 2) If none of the above fired, fall back to whole-layer coloring    if (painted === 0) {        var selectedLayers = comp.selectedLayers;        for (var i = 0; i < selectedLayers.length; i++) {            var layer = selectedLayers[i];            // — TEXT LAYER —            if (layer instanceof TextLayer) {                try {                    var textProp     = layer.property("Source Text");                    var textDoc      = textProp.value;      // a TextDocument object                    textDoc.fillColor   = rgbColor;                    // (optional) also enable and set stroke to the same color:                    textDoc.applyStroke = false;                    textDoc.strokeColor = rgbColor;                    textProp.setValue(textDoc);                    painted++;                } catch (e) {                    // silently skip if something’s off                }            // — SHAPE LAYER (vector) —            } else if (layer.matchName === "ADBE Vector Layer") {                if (findAndPaintFirstColor(layer.property("Contents"), rgbColor)) {                    painted++;                }            }        }    }    app.endUndoGroup();}